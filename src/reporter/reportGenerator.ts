import * as fs from 'fs/promises';
import * as path from 'path';

export type ReportFormat = 'md' | 'json' | 'txt' | 'none';

export interface ReportEntry {
  file: string;
  identifier: string;
  importStatement: string | null;
  source: string | null;
  isDefault: boolean;
}

export interface ReportData {
  timestamp: string;
  durationMs: number;
  directory: string;
  totalFilesScanned: number;
  filesWithMissing: number;
  totalMissing: number;
  totalResolved: number;
  totalUnresolved: number;
  dryRun: boolean;
  entries: ReportEntry[];
}

const REPORT_BASENAME = 'import-pilot-report';

function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  return `${(ms / 1000).toFixed(2)}s`;
}

export function generateMarkdownReport(data: ReportData): string {
  const lines: string[] = [];
  lines.push('# Import Pilot Report');
  lines.push('');
  lines.push(`| Field | Value |`);
  lines.push(`|-------|-------|`);
  lines.push(`| Date | ${data.timestamp} |`);
  lines.push(`| Duration | ${formatDuration(data.durationMs)} |`);
  lines.push(`| Directory | \`${data.directory}\` |`);
  lines.push(`| Mode | ${data.dryRun ? 'Dry run (no files modified)' : 'Applied'} |`);
  lines.push(`| Files scanned | ${data.totalFilesScanned} |`);
  lines.push(`| Files with missing imports | ${data.filesWithMissing} |`);
  lines.push(`| Total missing imports | ${data.totalMissing} |`);
  lines.push(`| Resolved | ${data.totalResolved} |`);
  lines.push(`| Unresolved | ${data.totalUnresolved} |`);
  lines.push('');

  const resolved = data.entries.filter((e) => e.importStatement);
  if (resolved.length > 0) {
    lines.push('## Resolved Imports');
    lines.push('');
    lines.push('| File | Identifier | Import Added |');
    lines.push('|------|------------|--------------|');
    for (const e of resolved) {
      const relFile = e.file;
      lines.push(`| \`${relFile}\` | \`${e.identifier}\` | \`${e.importStatement}\` |`);
    }
    lines.push('');
  }

  const unresolved = data.entries.filter((e) => !e.importStatement);
  if (unresolved.length > 0) {
    lines.push('## Unresolved Identifiers');
    lines.push('');
    lines.push('| File | Identifier |');
    lines.push('|------|------------|');
    for (const e of unresolved) {
      lines.push(`| \`${e.file}\` | \`${e.identifier}\` |`);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push('');
  lines.push('*Generated by [import-pilot](https://github.com/YosefHayim/import-pilot)*');
  lines.push('');
  return lines.join('\n');
}

export function generateTextReport(data: ReportData): string {
  const lines: string[] = [];
  lines.push('IMPORT PILOT REPORT');
  lines.push('='.repeat(50));
  lines.push(`Date:            ${data.timestamp}`);
  lines.push(`Duration:        ${formatDuration(data.durationMs)}`);
  lines.push(`Directory:       ${data.directory}`);
  lines.push(`Mode:            ${data.dryRun ? 'Dry run' : 'Applied'}`);
  lines.push(`Files scanned:   ${data.totalFilesScanned}`);
  lines.push(`Files affected:  ${data.filesWithMissing}`);
  lines.push(`Missing imports: ${data.totalMissing}`);
  lines.push(`Resolved:        ${data.totalResolved}`);
  lines.push(`Unresolved:      ${data.totalUnresolved}`);
  lines.push('');

  const resolved = data.entries.filter((e) => e.importStatement);
  if (resolved.length > 0) {
    lines.push('RESOLVED IMPORTS');
    lines.push('-'.repeat(50));
    for (const e of resolved) {
      lines.push(`  ${e.file}`);
      lines.push(`    ${e.identifier} â†’ ${e.importStatement}`);
    }
    lines.push('');
  }

  const unresolved = data.entries.filter((e) => !e.importStatement);
  if (unresolved.length > 0) {
    lines.push('UNRESOLVED IDENTIFIERS');
    lines.push('-'.repeat(50));
    for (const e of unresolved) {
      lines.push(`  ${e.file}: ${e.identifier}`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

export function generateJsonReport(data: ReportData): string {
  return JSON.stringify(data, null, 2) + '\n';
}

export async function writeReport(projectRoot: string, format: ReportFormat, data: ReportData): Promise<string | null> {
  if (format === 'none') return null;

  let content: string;
  let ext: string;

  switch (format) {
    case 'md':
      content = generateMarkdownReport(data);
      ext = '.md';
      break;
    case 'json':
      content = generateJsonReport(data);
      ext = '.json';
      break;
    case 'txt':
      content = generateTextReport(data);
      ext = '.txt';
      break;
    default:
      return null;
  }

  const filePath = path.join(projectRoot, `${REPORT_BASENAME}${ext}`);
  await fs.writeFile(filePath, content, 'utf-8');
  return filePath;
}
